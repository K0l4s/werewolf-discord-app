const { Client, GatewayIntentBits, ChannelType, PermissionsBitField } = require('discord.js');
require('dotenv').config(); // Th√™m d√≤ng n√†y
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildVoiceStates,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent
    ]
});

// L∆∞u tr·ªØ th√¥ng tin c√°c ph√≤ng
const voiceChannels = new Map();
const userChannels = new Map();
const creationChannels = new Map();

client.once('ready', () => {
    console.log(`‚úÖ Bot ƒë√£ s·∫µn s√†ng: ${client.user.tag}`);
});

client.on('voiceStateUpdate', async (oldState, newState) => {
    // Ng∆∞·ªùi d√πng join v√†o voice channel
    if (!oldState.channelId && newState.channelId) {
        await handleVoiceJoin(newState);
    }
    
    // Ng∆∞·ªùi d√πng r·ªùi kh·ªèi voice channel
    if (oldState.channelId && !newState.channelId) {
        await handleVoiceLeave(oldState);
    }
    
    // Ng∆∞·ªùi d√πng chuy·ªÉn channel
    if (oldState.channelId && newState.channelId && oldState.channelId !== newState.channelId) {
        await handleVoiceSwitch(oldState, newState);
    }
});

async function handleVoiceJoin(newState) {
    const channel = newState.channel;
    const member = newState.member;
    
    // Ki·ªÉm tra n·∫øu ƒë√¢y l√† channel t·∫°o ph√≤ng
    if (creationChannels.has(channel.id)) {
        await createUserChannel(channel, member);
        return;
    }
    
    // Ki·ªÉm tra n·∫øu ƒë√¢y l√† ph√≤ng c·ªßa ng∆∞·ªùi d√πng
    if (voiceChannels.has(channel.id)) {
        const channelInfo = voiceChannels.get(channel.id);
        channelInfo.members.add(member.id);
    }
}

async function handleVoiceLeave(oldState) {
    const channel = oldState.channel;
    const member = oldState.member;
    
    if (!channel) return;
    
    // Ki·ªÉm tra n·∫øu ƒë√¢y l√† ph√≤ng c·ªßa ng∆∞·ªùi d√πng
    if (voiceChannels.has(channel.id)) {
        const channelInfo = voiceChannels.get(channel.id);
        channelInfo.members.delete(member.id);
        
        // X√≥a ph√≤ng n·∫øu kh√¥ng c√≤n ai
        if (channel.members.size === 0) {
            await deleteUserChannel(channel);
        }
    }
}

async function handleVoiceSwitch(oldState, newState) {
    const oldChannel = oldState.channel;
    const newChannel = newState.channel;
    const member = newState.member;
    
    // X·ª≠ l√Ω r·ªùi kh·ªèi channel c≈©
    if (oldChannel && voiceChannels.has(oldChannel.id)) {
        const channelInfo = voiceChannels.get(oldChannel.id);
        channelInfo.members.delete(member.id);
        
        if (oldChannel.members.size === 0) {
            await deleteUserChannel(oldChannel);
        }
    }
    
    // X·ª≠ l√Ω join channel m·ªõi
    if (newChannel) {
        if (creationChannels.has(newChannel.id)) {
            await createUserChannel(newChannel, member);
        } else if (voiceChannels.has(newChannel.id)) {
            const channelInfo = voiceChannels.get(newChannel.id);
            channelInfo.members.add(member.id);
        }
    }
}

async function createUserChannel(creationChannel, member) {
    const guild = creationChannel.guild;
    const category = creationChannel.parent;
    
    try {
        // T·∫°o voice channel m·ªõi
        const userChannel = await guild.channels.create({
            name: `üîä ${member.user.username}'s Room`,
            type: ChannelType.GuildVoice,
            parent: category,
            permissionOverwrites: [
                {
                    id: member.id,
                    allow: [
                        PermissionsBitField.Flags.ManageChannels,
                        PermissionsBitField.Flags.ManageRoles,
                        PermissionsBitField.Flags.MoveMembers,
                        PermissionsBitField.Flags.MuteMembers,
                        PermissionsBitField.Flags.DeafenMembers,
                        PermissionsBitField.Flags.Speak
                    ]
                },
                {
                    id: guild.roles.everyone,
                    allow: [PermissionsBitField.Flags.ViewChannel],
                    deny: [PermissionsBitField.Flags.ManageChannels]
                }
            ]
        });
        
        // L∆∞u th√¥ng tin channel
        const channelInfo = {
            owner: member.id,
            members: new Set([member.id]),
            createdAt: Date.now()
        };
        
        voiceChannels.set(userChannel.id, channelInfo);
        userChannels.set(member.id, userChannel.id);
        
        // Di chuy·ªÉn ng∆∞·ªùi d√πng sang ph√≤ng m·ªõi
        await member.voice.setChannel(userChannel);
        
        // G·ª≠i tin nh·∫Øn x√°c nh·∫≠n
        const embed = {
            color: 0x00ff00,
            title: 'üéâ Ph√≤ng voice ƒë√£ ƒë∆∞·ª£c t·∫°o!',
            description: `Ch√†o m·ª´ng ƒë·∫øn ph√≤ng c·ªßa b·∫°n ${member.user.username}!`,
            fields: [
                {
                    name: 'üìù C√°c l·ªánh qu·∫£n l√Ω:',
                    value: '`!vc rename <t√™n>` - ƒê·ªïi t√™n ph√≤ng\n`!vc limit <s·ªë>` - Gi·ªõi h·∫°n th√†nh vi√™n\n`!vc transfer @user` - Chuy·ªÉn quy·ªÅn s·ªü h·ªØu\n`!vc kick @user` - ƒêu·ªïi th√†nh vi√™n\n`!vc close` - ƒê√≥ng ph√≤ng'
                }
            ],
            timestamp: new Date()
        };
        
        const dmChannel = await member.user.createDM();
        await dmChannel.send({ embeds: [embed] });
        
    } catch (error) {
        console.error('L·ªói khi t·∫°o channel:', error);
    }
}

async function deleteUserChannel(channel) {
    try {
        const channelInfo = voiceChannels.get(channel.id);
        if (channelInfo) {
            userChannels.delete(channelInfo.owner);
            voiceChannels.delete(channel.id);
            await channel.delete();
        }
    } catch (error) {
        console.error('L·ªói khi x√≥a channel:', error);
    }
}

// X·ª≠ l√Ω commands
client.on('messageCreate', async (message) => {
    if (message.author.bot) return;
    if (!message.content.startsWith('!vc')) return;
    
    const args = message.content.slice(4).trim().split(/ +/);
    const command = args.shift()?.toLowerCase();
    
    if (!command) {
        await showHelp(message);
        return;
    }
    
    try {
        switch (command) {
            case 'setup':
                await setupCreationChannel(message);
                break;
            case 'rename':
                await renameChannel(message, args);
                break;
            case 'limit':
                await setUserLimit(message, args);
                break;
            case 'transfer':
                await transferOwnership(message, args);
                break;
            case 'kick':
                await kickUser(message, args);
                break;
            case 'close':
                await closeChannel(message);
                break;
            case 'info':
                await showChannelInfo(message);
                break;
            default:
                await showHelp(message);
        }
    } catch (error) {
        console.error('L·ªói x·ª≠ l√Ω command:', error);
        await message.reply('‚ùå ƒê√£ c√≥ l·ªói x·∫£y ra khi th·ª±c hi·ªán l·ªánh!');
    }
});

async function setupCreationChannel(message) {
    if (!message.member.permissions.has(PermissionsBitField.Flags.Administrator)) {
        return message.reply('‚ùå B·∫°n c·∫ßn quy·ªÅn Administrator ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y!');
    }
    
    const voiceChannel = message.member.voice.channel;
    if (!voiceChannel) {
        return message.reply('‚ùå B·∫°n c·∫ßn ·ªü trong m·ªôt voice channel ƒë·ªÉ thi·∫øt l·∫≠p!');
    }
    
    creationChannels.set(voiceChannel.id, {
        guildId: message.guild.id,
        setupBy: message.author.id
    });
    
    await message.reply(`‚úÖ ƒê√£ thi·∫øt l·∫≠p ${voiceChannel.name} th√†nh channel t·∫°o ph√≤ng t·ª± ƒë·ªông!`);
}

async function renameChannel(message, args) {
    const newName = args.join(' ');
    if (!newName) {
        return message.reply('‚ùå Vui l√≤ng cung c·∫•p t√™n m·ªõi cho ph√≤ng!');
    }
    
    const userChannelId = userChannels.get(message.author.id);
    if (!userChannelId) {
        return message.reply('‚ùå B·∫°n kh√¥ng s·ªü h·ªØu ph√≤ng voice n√†o!');
    }
    
    const channel = message.guild.channels.cache.get(userChannelId);
    if (!channel) {
        userChannels.delete(message.author.id);
        return message.reply('‚ùå Ph√≤ng c·ªßa b·∫°n kh√¥ng t·ªìn t·∫°i!');
    }
    
    await channel.setName(newName);
    await message.reply(`‚úÖ ƒê√£ ƒë·ªïi t√™n ph√≤ng th√†nh: **${newName}**`);
}

async function setUserLimit(message, args) {
    const limit = parseInt(args[0]);
    if (isNaN(limit) || limit < 0 || limit > 99) {
        return message.reply('‚ùå Gi·ªõi h·∫°n ph·∫£i l√† s·ªë t·ª´ 0-99!');
    }
    
    const userChannelId = userChannels.get(message.author.id);
    if (!userChannelId) {
        return message.reply('‚ùå B·∫°n kh√¥ng s·ªü h·ªØu ph√≤ng voice n√†o!');
    }
    
    const channel = message.guild.channels.cache.get(userChannelId);
    if (!channel) {
        userChannels.delete(message.author.id);
        return message.reply('‚ùå Ph√≤ng c·ªßa b·∫°n kh√¥ng t·ªìn t·∫°i!');
    }
    
    await channel.setUserLimit(limit);
    const limitText = limit === 0 ? 'kh√¥ng gi·ªõi h·∫°n' : limit;
    await message.reply(`‚úÖ ƒê√£ ƒë·∫∑t gi·ªõi h·∫°n th√†nh vi√™n: **${limitText}**`);
}

async function transferOwnership(message, args) {
    if (args.length === 0 || !message.mentions.members.first()) {
        return message.reply('‚ùå Vui l√≤ng mention ng∆∞·ªùi d√πng ƒë·ªÉ chuy·ªÉn quy·ªÅn!');
    }
    
    const newOwner = message.mentions.members.first();
    const userChannelId = userChannels.get(message.author.id);
    
    if (!userChannelId) {
        return message.reply('‚ùå B·∫°n kh√¥ng s·ªü h·ªØu ph√≤ng voice n√†o!');
    }
    
    const channel = message.guild.channels.cache.get(userChannelId);
    if (!channel) {
        userChannels.delete(message.author.id);
        return message.reply('‚ùå Ph√≤ng c·ªßa b·∫°n kh√¥ng t·ªìn t·∫°i!');
    }
    
    // C·∫≠p nh·∫≠t permissions
    await channel.permissionOverwrites.edit(message.author.id, {
        ManageChannels: null,
        ManageRoles: null,
        MoveMembers: null
    });
    
    await channel.permissionOverwrites.edit(newOwner.id, {
        ManageChannels: true,
        ManageRoles: true,
        MoveMembers: true
    });
    
    // C·∫≠p nh·∫≠t th√¥ng tin s·ªü h·ªØu
    const channelInfo = voiceChannels.get(channel.id);
    channelInfo.owner = newOwner.id;
    voiceChannels.set(channel.id, channelInfo);
    
    userChannels.delete(message.author.id);
    userChannels.set(newOwner.id, channel.id);
    
    await message.reply(`‚úÖ ƒê√£ chuy·ªÉn quy·ªÅn s·ªü h·ªØu ph√≤ng cho ${newOwner.user.username}!`);
}

async function kickUser(message, args) {
    if (args.length === 0 || !message.mentions.members.first()) {
        return message.reply('‚ùå Vui l√≤ng mention ng∆∞·ªùi d√πng ƒë·ªÉ ƒëu·ªïi!');
    }
    
    const targetMember = message.mentions.members.first();
    const userChannelId = userChannels.get(message.author.id);
    
    if (!userChannelId) {
        return message.reply('‚ùå B·∫°n kh√¥ng s·ªü h·ªØu ph√≤ng voice n√†o!');
    }
    
    const channel = message.guild.channels.cache.get(userChannelId);
    if (!channel) {
        userChannels.delete(message.author.id);
        return message.reply('‚ùå Ph√≤ng c·ªßa b·∫°n kh√¥ng t·ªìn t·∫°i!');
    }
    
    // Ki·ªÉm tra n·∫øu ng∆∞·ªùi d√πng ƒëang trong ph√≤ng
    if (targetMember.voice.channelId !== channel.id) {
        return message.reply('‚ùå Ng∆∞·ªùi d√πng n√†y kh√¥ng ·ªü trong ph√≤ng c·ªßa b·∫°n!');
    }
    
    // ƒê√° ng∆∞·ªùi d√πng kh·ªèi voice channel
    await targetMember.voice.setChannel(null);
    await message.reply(`‚úÖ ƒê√£ ƒëu·ªïi ${targetMember.user.username} kh·ªèi ph√≤ng!`);
}

async function closeChannel(message) {
    const userChannelId = userChannels.get(message.author.id);
    if (!userChannelId) {
        return message.reply('‚ùå B·∫°n kh√¥ng s·ªü h·ªØu ph√≤ng voice n√†o!');
    }
    
    const channel = message.guild.channels.cache.get(userChannelId);
    if (!channel) {
        userChannels.delete(message.author.id);
        return message.reply('‚ùå Ph√≤ng c·ªßa b·∫°n kh√¥ng t·ªìn t·∫°i!');
    }
    
    // Di chuy·ªÉn t·∫•t c·∫£ th√†nh vi√™n ra kh·ªèi ph√≤ng
    for (const [memberId, member] of channel.members) {
        await member.voice.setChannel(null);
    }
    
    await deleteUserChannel(channel);
    await message.reply('‚úÖ ƒê√£ ƒë√≥ng ph√≤ng voice c·ªßa b·∫°n!');
}

async function showChannelInfo(message) {
    const userChannelId = userChannels.get(message.author.id);
    if (!userChannelId) {
        return message.reply('‚ùå B·∫°n kh√¥ng s·ªü h·ªØu ph√≤ng voice n√†o!');
    }
    
    const channel = message.guild.channels.cache.get(userChannelId);
    if (!channel) {
        userChannels.delete(message.author.id);
        return message.reply('‚ùå Ph√≤ng c·ªßa b·∫°n kh√¥ng t·ªìn t·∫°i!');
    }
    
    const channelInfo = voiceChannels.get(channel.id);
    const memberCount = channel.members.size;
    const userLimit = channel.userLimit || 'Kh√¥ng gi·ªõi h·∫°n';
    
    const embed = {
        color: 0x0099ff,
        title: `üìä Th√¥ng tin ph√≤ng: ${channel.name}`,
        fields: [
            { name: 'üëë Ch·ªß s·ªü h·ªØu', value: `<@${channelInfo.owner}>`, inline: true },
            { name: 'üë• Th√†nh vi√™n', value: `${memberCount} ng∆∞·ªùi`, inline: true },
            { name: 'üìà Gi·ªõi h·∫°n', value: userLimit.toString(), inline: true },
            { name: 'üïê T·∫°o l√∫c', value: `<t:${Math.floor(channelInfo.createdAt / 1000)}:R>`, inline: true }
        ],
        timestamp: new Date()
    };
    
    await message.reply({ embeds: [embed] });
}

async function showHelp(message) {
    const embed = {
        color: 0x0099ff,
        title: 'üéÆ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng Voice Channel Manager',
        description: 'C√°c l·ªánh qu·∫£n l√Ω ph√≤ng voice:',
        fields: [
            {
                name: 'üõ†Ô∏è Thi·∫øt l·∫≠p',
                value: '`!vc setup` - Thi·∫øt l·∫≠p voice channel hi·ªán t·∫°i th√†nh channel t·∫°o ph√≤ng (Admin only)'
            },
            {
                name: 'üìù Qu·∫£n l√Ω ph√≤ng',
                value: '`!vc rename <t√™n>` - ƒê·ªïi t√™n ph√≤ng\n`!vc limit <s·ªë>` - ƒê·∫∑t gi·ªõi h·∫°n th√†nh vi√™n (0-99)\n`!vc info` - Xem th√¥ng tin ph√≤ng'
            },
            {
                name: 'üë• Qu·∫£n l√Ω th√†nh vi√™n',
                value: '`!vc transfer @user` - Chuy·ªÉn quy·ªÅn s·ªü h·ªØu\n`!vc kick @user` - ƒêu·ªïi th√†nh vi√™n\n`!vc close` - ƒê√≥ng ph√≤ng'
            }
        ],
        footer: { text: 'T·ª± ƒë·ªông t·∫°o ph√≤ng khi join v√†o channel t·∫°o ph√≤ng' }
    };
    
    await message.reply({ embeds: [embed] });
}

// X·ª≠ l√Ω l·ªói
process.on('unhandledRejection', error => {
    console.error('L·ªói kh√¥ng x·ª≠ l√Ω:', error);
});

// Kh·ªüi ƒë·ªông bot
client.login(process.env.DISCORD_TOKEN);